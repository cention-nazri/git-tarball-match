#!/usr/bin/env perl
use strict;
use warnings;
use Getopt::Long;
use File::Basename;

use File::Temp qw/tempdir/;

my $ignore_pattern;
my $verbose;
my $debug = 0;
my $strip_components = 1;
my $commit;
my $diffline;
my $diff;
my $opt_sort;
my $xdir = tempdir( CLEANUP => 1 );
my $bdir = tempdir( CLEANUP => 1);

$SIG{USR1} = sub {
	print STDERR "Got USR1, toggling verbose mode.\n";
	$verbose = ! $verbose;
};

GetOptions("ignore=s" => \$ignore_pattern,
	"verbose" => \$verbose,
	"strip-components=i" => \$strip_components,
	"diff-line" => \$diffline,
	"diff" => \$diff,
	"sort" => \$opt_sort,
	"debug=i" => \$debug,
	"commit=s" => \$commit,
) or die "Error in args";

if ($debug) {
	$|++;
}

sub verbose {
	my ($text, $level) = @_;
	print "$text\n" if ($verbose);
}
sub debug {
	my ($text, $debug_level) = @_;
	if (!defined $debug_level) {
		$debug_level = 0;
	}
	if ($debug > $debug_level) {
		print "$text\n";
	}
}
sub usage {
	print "Usage: $0 <tarball>\n";
}

if (scalar @ARGV == 0) {
	usage();
	exit 1;
}

sub pause {
	my ($text) = @_;
	print "$text\n";
	<STDIN>;
}

sub run {
	my ($cmd) = @_;
	verbose "$cmd";
	system("$cmd") == 0
		or die "$cmd: $?";
}

sub md5sum_out_to_hash {
	my ($md5sum) = @_;
	chomp $md5sum;
	my @lines = split /\n/, $md5sum;
	my %hash;
	foreach my $l (@lines) {
		if (defined $ignore_pattern && $l =~ /$ignore_pattern/) {
			verbose "Ignore: $l";
			next;
		}

		my ($md5, $file) = $l =~ /([0-9a-f]+)\s+(.*)/;
		#print "file [$file] md5 [$md5]\n";
		$hash{$file} = $md5;
	}
	return %hash;
}

sub get_git_md5sum {
	my ($commit_sha1) = @_;
	my %hash;
	#open my $fd, '-|', "git ls-files --with-tree=$commit_sha1" or die "git ls-files: $?";
	my $cmd = "git ls-tree -r --name-only $commit_sha1";
	open my $fd, '-|', $cmd or die "$cmd: $?";
	my $tar_stderr_file = '/dev/shm/error.txt';
	while (my $file = <$fd>) {
		chomp $file;
		my $md5_cmd = "{ git show '$commit_sha1:./$file'|md5sum|awk '{print \$1}'; } 2> $tar_stderr_file";
		my $md5 = `$md5_cmd`;
		if ( -s $tar_stderr_file) {
			print "$cmd ";
			print "-- [$md5_cmd]\n";
			system("echo cat $tar_stderr_file; cat $tar_stderr_file");
			print "Press any key to continue...";
			<STDIN>;
		}
		chomp $md5;
		$hash{$file} = $md5;
	}
	close $fd;
	return %hash;
}

sub show_diff {
	my ($commit, $file) = @_;

	my $tgz_file = "$xdir/$file";
	my $git_file = "$bdir/" . basename($file) . "-$commit";
	my $cmd = "git show $commit:./$file > $git_file";
	system($cmd);
	my $git_diff = `git diff --no-index '$tgz_file' '$git_file'`;
	if ($diffline) {
		chomp($git_diff);
		my @lines = split "\n", $git_diff;
		@lines = grep !/^(---|\+\+\+) /, @lines;
		my $nadd = grep /^\+/, @lines;
		my $nrem = grep /^-/, @lines;
		print "  $file -$nrem,+$nadd\n";
	} elsif ($diff) {
		print $git_diff;
	}
}

sub md5_score {
	my ($commit, $tgz_md5, $git_md5) = @_;
	my $nmatch = 0;
	my $ncompared = 0;
	my $nnonmatch = 0;
	foreach my $file (keys %$git_md5) {
		if ($tgz_md5->{$file}) {
			if ($tgz_md5->{$file} eq $git_md5->{$file}) {
				#debug "        match.";
				$nmatch += 1;
			} else {
				$nnonmatch += 1;
				debug " ! $file";
				if ($diffline || $diff) {
					show_diff($commit, $file);
				}
				#debug "      md5 $tgz_md5->{$file}";
				#debug "  git md5 $git_md5->{$file}";
			}
			$ncompared++;
		}
	}
	#my $total_files = scalar keys %$tgz_md5;

	my $score = 0;
	if ($ncompared > 0) {
		$score = $nmatch / $ncompared;
	}
	if ($nnonmatch > 0) {
		debug " $nnonmatch/$ncompared files differ";
	}
	return {
		commit => $commit,
		score => $score,
		ncompared => $ncompared,
		nnonmatch => $nnonmatch,
		nmatch => $nmatch,
	};
}

sub format_score_report {
	my ($score_data) = @_;

	return sprintf("%s %.7f (%d/%d files differ)",
		$score_data->{commit}, $score_data->{score},
		$score_data->{nnonmatch}, $score_data->{ncompared}
	);
	#return "$commit $score_data->{score} ($score_data->{nnonmatch}/$score_data->{ncompared} files differ)";
}

my $tarball=$ARGV[0];
#print "workdir $xdir\n";

run("tar --strip-components=$strip_components -C $xdir -xf $tarball");
my $md5sum_cmd = "find $xdir -type f -print|xargs md5sum|sed -e 's,$xdir/',,";
my $md5sum = `$md5sum_cmd`;
my %tarmd5sum = md5sum_out_to_hash($md5sum);

my $git_log;
my $git_log_cmd = 'git log --format=%H';
if (defined $commit) {
	$git_log_cmd = "git log -1 --format=%H $commit";
}
open $git_log, '-|', $git_log_cmd or die "git log: $?";
my %scores;
my $highest_score = {
	score => 0,
};
my $max_nmatched = 0;
my $ncompared = 0;
while (my $h = <$git_log>) {
	$ncompared++;
	chomp $h;
	my %gitmd5sum = get_git_md5sum($h);
	debug $h;
	my $s = md5_score($h, \%tarmd5sum, \%gitmd5sum);
	if ($s->{nmatch} > $max_nmatched) {
		$max_nmatched = $s->{nmatch};
	}
	if ($s->{score} == 1 && $s->{nmatch} >= $max_nmatched) {
		print "Matching commit hash: $h\n";
		exit 0;
	}
	if ($s->{score} > $highest_score->{score}) {
		$highest_score = $s;
	}
	my $out_txt = format_score_report($s);
	if (!$opt_sort) {
		print "$out_txt\n";
	} else {
		verbose $out_txt;
	}
	$scores{$h} = $s;
}

if ($opt_sort) {
	foreach my $h (sort { $scores{$a}->{score} <=> $scores{$b}->{score} } keys %scores) {
		my $s = $scores{$h};
		print format_score_report($s) . "\n";
	}
} else {
	if ($ncompared > 1) {
		print "Closest match: " . format_score_report($highest_score) . "\n";
	}
}
